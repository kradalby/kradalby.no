Title: TDT4145 - Datamodellering og databasesystemer
Summary: Mine notater for TDT4145. 

[TOC]

# Intro
Mine notater for TDT4145.
De er på norsk, er fulle av skrivefeil, og sikkert litt faktafeil.
Disse er beregnet på personlig bruk, så jeg går ikke inn for noe mer en det jeg forstår og som hjelper meg å huske.

## Hvorfor er de her?
Fordi det er digg å skrive Markdown, og her var det enkelt å gjøre de tilgjenglig som pene kompilerte html sider.

# Ord og utrykk

**Database**

En database er en samling med data

**Data**

Informasjon som har en mening alene

**Miniverden**

En database representerer informasjon fra deler av vår verden, den lille delen databasen inneholder informasjon om kaller vi miniverden

**Database modell**

En model som gjengir den logiske strukturen til en database, for eksempel et ER-diagram

**DBMS**

En samling programvare som lar en bruker lage og håndtere en database. Eks. MySQL, PostgreSQL.

**Database system**

En felles betegnelse for database, database modell og DBMS.


# Typer feil
Det er mange typer feil. Feil 1-4 er mest vanlig, 5 og 6 er mindre vanlig og vanskligere å gjennopprette.

1. Datamaskin kræsj/feil
2. Transaksjons eller systemfeil
3. Lokale feil eller exceptions som ikke går gjennom transaksjoner
4. Concurrency control enforcement (feil som oppstår om noe ødelegger concurrency)
5. Harddisk kræsj
6. Fysiske problemer og katastrofer

# Relasjonsalgebra

Seleksjon σ
Velge ut rader med data basert på kriterie.

Prosjeksjon π
Velge ut kolonner med data basert på kolonnenavn

Union ⋃
Gir en liste med alle verdier fra to datasett

Snitt ⋂
Gir en liste med kun de verdiene som er like i to datasett

Differanse -
Gir en liste med det som er forskjellig fra lista A og B. Returnerer A - B.

Naturlig forening *
Antar hvilke like rader som skal slås sammen slik at den kan returnere en god sammenslått liste.
Bruk Forening

Forening ⨝
Gir en sammensatt liste fra to datasett hvor resultater er basert på en felles kolonne.


Kartesisk produkt X
Gir en gigantisk kryss liste, med mindre man ikke kan, bruk heller Forening.

Divisjon  /
Lar deg velge ut hente ut data fra en stor liste hvor den kun returnerer data som har fullført alle kriterier.

Funksjoner F
Man kan bruke funksjoner i Relasjonsalgebra, dette er normale SQL funksjoner.

Mye brukt: Sum, Avg, Count

Grupperingsoperasjon/Aggregation ∑
Man kan bruke grupperingsoperasjoner for å foreksempel kalle funksjoner på flere ting i et dataset.

# SQL

**Distinct**

Velg kun en av hver slik at output har kun unike verdier.

**Order by**

Sorterer på kolonne, med ASC eller DESC

**Count()**

Teller antall forekomster av alt(*) eller av en gitt verdi. Kan navngi kolonne ved bruk av AS.

**AS**

Gi noe et annet navn/alias.

**Inner join**

Kan brukes for å fylle ut en verdi fra en hjelpe tabell, foreksempel en poststeder tabell ved hjelp av postnummer
select kid, navn, adresse, kunde.postnr, poststed from kunde inner join poststeder on kunde.postnr = poststeder.postnr;

**Like**

Brukes for å sammenlinge verdier, litt løsere en =.

**Union**

Sette sammen kolonner, foreksempel legge alle fornavn og etternavn i samme kolonne og kalle den alle navn.

**Left outer join**

Slår sammen tabell A og B, og vil alltid ha med alle rader fra den venstre (A) siden. Om den ikke finner et matchende sett når den kjører ON vil den fortsatt ta med raden, men fylle ut med NULL.

**Wildcard %**

Brukes for å matche alt mulig. Kan brukes til å finne alle ting som begynner på K%.

# Normalisering

## Nøkler
**Supernøkkel**

Unik identifikator for rad.

**Kandidatnøkkel**

unik, minimal identifikator.

**Primærnøkkel**

Den viktigste blant kandidatnøklene.

**Alternaltiv nøkkel**

kandidatnøkkel som ikke er primærnøkkel.

**Nøkkelattributt**

Attributt som er med i en eller flere kandidatnøkler.

**Ikke-Nøkkelattributt**

Attributt som ikke er med i noen kandidatnøkkel.

    Antar at et kjøretøy har en bestemt fører på en bestemt dag og tid. Antar også at en person kan føre bare et kjøretøy på en bestemt dag og tid. Vi får da to funksjonelle avhengigheter:
    • Regnr, Dato, Tid -> FørerPnr
    • FørerPnr, Dato, Tid -> RegNr
    Det kan være flere skadede personer i en ulykke. Kandidatnøklene for tabellen blir da:
    • RegNr, Dato, Tid, SkadetPn
    FørerPnr, Dato, Tid, SkadetPnr


## Normalform

### 1NF

1. Det kan ikke være noen repeterende grupper.
2. All data må være atomisk
3. Alle felter må ha et unikt navn
4. Den har en primary key

### 2NF

1. Den er 1NF
2. Alle ikke nøkkelattributter _er_ avhengig av _alle deler_ av primærnøkkelen.

Tabellen er på 2NF siden nøkkelen består av et enkelt attributt, det kan da ikke oppstå noen delvise funksjonelle avhengigheter.

### 3NF

1. Den er på 2NF
2. Det er ingen transetive funksjonelle avhengigheter.

### BCNF

1. Den er på 3NF
2. For alle A -> B er A en nøkkel

### Fordeler med høy NF
Unngår redundans og problemer med innsettning, oppdatering, sletting.

### Ulemper med høy NF
Flere tabeller, må joine mer, mer kompliserte spørringer.

### Huskeliste ved oppsplitting
1. Attributtbevaring
2. Normalform
3. Bevaring av funksjonelle avhengigheter
4. Taps-løs-join-egenskap

# Lagring og indeksering

## Lagringsstrukturer

### Heapfile
Simple lagringsstruktur, innsettning gjøres bakerst i filen, kostnad O(1).
Søk og uthenting krever linært søk gjennom filen, kostnad O(n).
Sletting merker noe for sletting, kostnad O(1) + kostnaden for å finne elementet.

### Hash buckets
En hash funksjon vil la deg kalkulere en nøkkel for en addresse basert på verdien av dataene. En god hash funksjon vil fordele data gjevnt over det tilgjenglige området. Det er lov å anta 60% fyll. Om vi ser bort fra krasj, har hash buckets en kostnad på O(1) for alt. Hash er dårlig for søk på rekkevidde.

### B+ tree
Awesome tre struktur, trygt å anta høyde på 3 eller 4. Kostnad O(log n). Om filer er stabile, bruk ISAM.

### ISAM 
Index Sequential Access Method

## Hash skjemaer
### Extendible hashing
Ganske bra, behandler hashen som en bitstreng. Re-hashing skjer underveis, en bøtte av gangen. Både LSB og MSB er vanlig.

### Linear hashing
Gjør det mulig å ekspandere tabellen en slot av gangen, round robin.

## Formler

### Static hash søketid kan regnes ut som:
antall poster i rad * blokk nummer + antall poster i rad * blokk / antall poster

Gjennomsnittlig antall blokker aksessert: 10 poster*1 blokk + 3 poster *2 blokker = 16 blokker. 16 blokker/13 poster = 1,23 blokker/post

## Indekser
### Ulemper
1. Ekstra plass - marginal
2. Generering av indekser - medium
3. Vedlikeholding - Kan i teorien koste mer en det gir. (For eksempel i en database med mer skriving en lesing.

### Fordeler er avhengig av:
1. Størrelsen på tabellen (og muligens designet)
2. Hvordan data er distribuert
3. Query vs update loads

# Transaksjoner

En transaksjon er en enhet av arbeid som utføres i en DBMS.

## ACID
**Atomicity**

En transaksjon er alltid gjennomført i en helhet, om det er en crash underveis i en transaksjon vil den heller fjerne de spørringene som er blitt kjørt.

**Consistency**

En transaksjon skal kjøre fra start til slutt uten å bli forstyrret av en annen transaksjon. En database skal tas fra en konsistent tilstand til en annen konsistent tilstand.

**Isolation**

En transaksjon skal gi inntrykk av å kjøre som om den blir kjørt isolert selvom den blir kjørt i parralell med andre transaksjoner.

**Durability**

Hvis det er et systemkræsj og en tranaksjon er commited vil den garantere at dataene er i databasen.

## Transaksjonens livsykel.
1. Begynn transaksjon
2. Utførs spørringer
3. Om ingen feil skjer, commit og slutt.
4. Om feil skjer, rull tilbake og slutt.






Fantomer - rader som dukker opp andre gangen man leser en liste.


